<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<script>
		var speed = 1;
		
		var WIDTH = 25;
		var HEIGHT = 25;

		var puzzle;

		var rules = [];

		var map0 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map1 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
			1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
			1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
			1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
			1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
			1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
			1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
			1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
			1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map2 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,
			1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,
			1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,
			1,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1,
			1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,0,0,0,1,
			1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,0,1,1,1,
			1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,0,1,0,1,0,0,0,1,
			1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,
			1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1,1,1,0,1,
			1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,0,0,0,0,0,1,
			1,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,
			1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,0,1,0,0,0,1,0,1,0,1,
			1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,1,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,
			1,0,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,
			1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,1,
			1,0,0,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,
			1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,
			1,0,1,0,0,1,0,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,
			1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,
			1,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map3 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map4 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,
			1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,
			1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
			1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,
			1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,
			1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,
			1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,
			1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
			1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
			1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,
			1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
			1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,
			1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
			1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,
			1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
			1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,
			1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map5 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,
			1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,1,
			1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
			1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
			1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var map6 = [
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,
			1,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,1,
			1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,
			1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
			1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
			1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,1,0,1,
			1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,
			1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
			1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,
			1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,
			1,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
			1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,
			1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,
			1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,
			1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,
			1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,
			1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,
			1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		];
		var maps = [map0, map1, map2, map3, map4, map5, map6];
		var map = map0;
		
		var picobot = [4, 21];
		var picobot_animation = 'red';
		var picobot_animation_frame = 0;
		var picobot_cell;

		var world;

		var OFFSET = 1;

		var surroundings;

		var Direction = {
			UP : "N",
			DOWN : "S",
			LEFT : "W",
			RIGHT : "E"
		}

		var State = {
			IDLE : "idle",
			MOVING : "moving"
		}

		var picobot_state = 0;
		var picobot_rule_invoked = "";

		var state = State.IDLE;
		var movingDirection = Direction.UP;
		var updateTimer = "";
		var oneStep = false;

		var textarea = "";
		var numEmptyCells;
		var stepNum = 0;
		var complete = false;
		var verboseLog = false;
		
		var Color = {
			RED : "red",
	  		GREEN: "green"
		}

		function randomPicobot() {
			var x = 0;
			var y = 0;
			do {
				// random btw 1 and 23 (0 and 24 always walls)
				x = Math.floor(Math.random() * (WIDTH - 2) + 1);
				y = Math.floor(Math.random() * (HEIGHT - 2) + 1);
			} while ( map[y * WIDTH + x] == 1);
			picobot = [x,y];
		}
		
		function changeMap(menu) {
			stopPicobot();
			var mapNum = menu.options[menu.selectedIndex].value;
			map = maps[mapNum];
			initialize();
		}
		
		function changeSpeed(menu) {
			speed = menu.options[menu.selectedIndex].value;
			if (updateTimer != "") {
				window.clearInterval(updateTimer);
				updateTimer = window.setInterval("update()", speed);
			}
		}
		
		function toggleLog(button) {
			if (button.checked) {
				document.getElementById('surroundings').style.display="block";
			} else {
				document.getElementById('surroundings').style.display="none";			
			}
		}
		
		function toggleVerbose(button) {
			if (button.checked) {
				verboseLog = true;
			} else {
				verboseLog = false;
			}
		}
		
		function isWall(x, y) {
			x|=0;
			y|=0;
			if (x < 0 || x >= WIDTH) {
				return true;
			}

			if (y < 0 || y >= HEIGHT) {
				return true;
			}
			
			return !puzzle[y * WIDTH + x].src.match("empty");
		}

		function chooseWall(index) {
			// Look all around and choose which style of wall is best

			// 0 - Empty
			// 1, 2, 3, 4 - Single wall, 1 = left wall, clockwise rotation
			// 5, 6, 7, 8 - Double (Corner) wall, 5 = TopLeft wall, clockwise rotation
			// 9, 10, 11, 12 - Triple wall, 9 = No wall to Right, clockwise rotation
			// 13, 14 - Double (Straight) wall, 13 = walls to left and right, 14 = top and bottom
			// 15 - All Four Walls
			// 16, 17, 18, 19 - Small Corners, 16 = corner to TopLeft, clockwise rotation

			var x = index % WIDTH;
			var y = index / WIDTH;

			var wallTop = isWall(x, y-1);
			var wallBottom = isWall(x, y+1);
			var wallLeft = isWall(x-1,y);
			var wallRight = isWall(x+1,y);

			var wallTopLeft = isWall(x-1,y-1);
			var wallTopRight = isWall(x+1,y-1);
			var wallBottomLeft = isWall(x-1,y+1);
			var wallBottomRight = isWall(x+1,y+1);

			var wall_index = 0;

			if (!wallLeft) {
				wall_index += 1;
			}
			else if (wallBottom && !wallBottomLeft) {
				wall_index += 2;
			}
			if (!wallBottom) {
				wall_index += 10;
			}
			else if (wallRight && ! wallBottomRight) {
				wall_index += 20;
			}
			if (!wallRight) {
				wall_index += 100;
			}
			else if (wallTop && !wallTopRight) {
				wall_index += 200;
			}
			if (!wallTop) {
				wall_index += 1000;
			}
			else if (wallLeft && !wallTopLeft) {
				wall_index += 2000;
			}

			wall_index = "" + wall_index;
			while (wall_index.length < 4) {
				wall_index = "0" + wall_index;
			}

			return wall_index;
		}

		function setWall(index, wall_index) {
			puzzle[index].src = "img/wall_" + wall_index + ".png";
		}

		function toggleWall(index) {
			if (updateTimer != "") {
				return;	// no changing walls while running
			}
			if (puzzle[index].src.match("empty")) {
				setWall(index, chooseWall(index));
				numEmptyCells--;
			}
			else {
				puzzle[index].src = "img/empty_uncleared.png";
				numEmptyCells++;
			}

			// Choose walls around the current space
			var x = index % WIDTH;
			var y = index / WIDTH;
			x |= 0;
			y |= 0;

			var xp;
			var yp;
			for(xp = x-1; xp <= x+1; xp++) {
				for(yp = y-1; yp <= y+1; yp++) {
					var idx = yp * WIDTH + xp;
					if (xp >= 0 && xp < WIDTH && yp >= 0 && yp < HEIGHT && isWall(xp, yp)) {
						setWall(idx, chooseWall(idx));
					}
				}
			}
		}

		function evaluatePicobotPosition() {
			var i = picobot[1] * WIDTH + picobot[0];
			var cell = document.getElementById('cell_' + i);

			if (cell.src.match(/empty_uncleared.png$/)) {
				cell.src = "img/empty_cleared.png";
				numEmptyCells--;
				if (numEmptyCells == 0) {
					stopPicobot();
					complete = true;
					return;
				}
			}
									
			if (picobot_rule_invoked != "") {				
				// Update picobot
				picobot_state = picobot_rule_invoked.next_state;
			}

		}

		function chooseRule() {
			for(var i = 0; i < rules.length; i++) {
				var ruleApplies = false;
				var rule = rules[i];
				if (rule.state == picobot_state) {
					ruleApplies = true;
					for(var k = 0; k < rule.match.length; k++) {
						if (rule.match[k] == 'N' && !isWall(picobot[0], picobot[1]-1)) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'n' && isWall(picobot[0], picobot[1]-1)) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'S' && !isWall(picobot[0], picobot[1]+1)) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 's' && isWall(picobot[0], picobot[1]+1)) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'E' && !isWall(picobot[0]+1, picobot[1])) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'e' && isWall(picobot[0]+1, picobot[1])) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'W' && !isWall(picobot[0]-1, picobot[1])) {
							ruleApplies = false;
							break;
						}
						if (rule.match[k] == 'w' && isWall(picobot[0]-1, picobot[1])) {
							ruleApplies = false;
							break;
						}
					}
				}
				if (ruleApplies) {
					return rule;
				}
			}
			return "";
		}
	
		function changePicobotColor(color) {
			picobot_animation = color;
			picobot_cell.style.backgroundImage = "url('img/" + color + ".gif')"
		}

		function createWorld() {
			stepNum = 0;
			surroundings.innerText = "";
			picobot_state = 0;
			
			puzzle = new Array(WIDTH * HEIGHT);

			world = document.getElementById('world');
			
			var world_box_HTML = "";
			
			for(i = 0; i < WIDTH*HEIGHT; i++) {
				world_box_HTML = world_box_HTML + '<img id="cell_' + i + '" src="img/empty_uncleared.png" class="cell" onclick="toggleWall(' + i + ')" />'
			}
			world.innerHTML = world_box_HTML + '<div id="picobot" class="picobot_cell"></div>';

			picobot_cell = document.getElementById('picobot');
			updatePicobotImage();

			for(i = 0; i < WIDTH*HEIGHT; i++) {
				puzzle[i] = document.getElementById('cell_' + i);
			}

			numEmptyCells = WIDTH*HEIGHT;
			for(i = 0; i < WIDTH*HEIGHT; i++) {
				if (map[i] == 1) {
					toggleWall(i);
				}
			}
		}

		function updatePicobotImage() {
			picobot_cell.style.top = (picobot[1] * 20 + OFFSET) + "px";
			picobot_cell.style.left = (picobot[0] * 20 + OFFSET) + "px";
		}

		function nudgePicobot(direction) {
			var startAgain = false;
			if (updateTimer != "") {
				startAgain = true;
				stopPicobot();
			}

			movePicobot(direction);
			updatePicobotImage();

			state = State.IDLE;

			evaluatePicobotPosition();

			if (startAgain) {
				startPicobot();
			}
		}

		function moveError(direction) {
			stopPicobot();
			surroundings.innerHTML += "STEP "+stepNum+": Error; PicoBot can't move "+direction+" because there's a wall in that direction\n";
			surroundings.scrollTop = surroundings.scrollHeight; // scroll to end
			surroundings.style.display = "block";
			document.getElementById('logCheckbox').checked = true;
			document.getElementById('startStop').disabled = true;
			document.getElementById('step').disabled = true;
		}
		
		function movePicobot(direction) {
			moved = false;
			if(direction == Direction.UP) {
				if (picobot[1] > 0 && !isWall(picobot[0], picobot[1]-1)) {
					picobot[1]--;
					moved = true;
				} else {
					moveError(direction);
				}
			}
			else if (direction == Direction.DOWN) {
				if (picobot[1] < HEIGHT-1 && !isWall(picobot[0], picobot[1]+1)) {
					picobot[1]++;
					moved = true;
				} else {
					moveError(direction);
				}
			}
			else if (direction == Direction.LEFT) {
				if (picobot[0] > 0 && !isWall(picobot[0]-1, picobot[1])) {
					picobot[0]--;
					moved = true;
				} else {
					moveError(direction);
				}
			}
			else { /* Direction.RIGHT */
				if (picobot[0] < WIDTH-1 && !isWall(picobot[0]+1, picobot[1])) {
					picobot[0]++;
					moved = true;
				} else {
					moveError(direction);
				}
			}

			if (moved) {
				state = State.MOVING;
				movingDirection = direction;
			}
			else {
				state = State.IDLE;
			}
		}

		function initialize() {
			surroundings = document.getElementById('surroundings');
						
			randomPicobot();
			
			if (textarea == "") {
				createCodeBox('codebox');
			}
			
		
			interpretRules();
			step();
			// let the user start it running
			// startPicobot();
		}

		function createCodeBox(id) {
			textarea = document.getElementById(id);
			var numbers = document.createElement('div');

			textarea.parentNode.insertBefore(numbers, textarea);
			numbers.appendChild(textarea);

			numbers.className = "code_box_numbers";
			numbers.style.width = (textarea.offsetWidth + 30) + "px";
			textarea.style.position = 'absolute';
			textarea.style.left = '30px';
			numbers.style.height = (textarea.offsetHeight + 2) + "px";
			numbers.style.overflow = 'hidden';
			numbers.style.position = 'relative';
			numbers.style.width = (textarea.offsetWidth + 30) + "px";

			var lines = document.createElement('div');
			lines.style.position = 'absolute';
			lines.style.top = 1 + "px";
			lines.style.left = 0 + "px";
			lines.style.width = 23 + "px";

			numbers.insertBefore(lines, textarea);

			lines.style.textAlign = "right";
			lines.className = "code_box_lines";

			var string = '';
			for(var no=1;no<200;no++){
				if(string.length>0) {
					string = string + '<br>';
				}
				string = string + no;
			}

			lines.innerHTML = string;

			textarea.onscroll = function() {
				updateLines(lines, textarea);
			}	
		}

		var firstLine = 1;
		function updateLines(lines, textarea) {
			var lineHeight = 16;
			var visibleLine = textarea.scrollTop / parseInt(textarea.style.lineHeight);
			visibleLine = textarea.scrollTop / lineHeight + 1;
			visibleLine |= 0;

			var numLines = parseInt(textarea.style.height) / lineHeight;
			numLines = 500 / lineHeight;
			numLines |= 0;

			if (visibleLine != firstLine) {
				firstLine = visibleLine|0;
				var i;
				var str = '';
				for(i = firstLine; i < firstLine + numLines + 1; i++) {
					str = str + i + "<br />";
				}
				lines.innerHTML = str;
			}
				
			var diff = textarea.scrollTop % lineHeight;
			lines.style.top = (-diff + 1) + "px" 
		}

		function startStop() {
			if (updateTimer == "") {
				startPicobot();
			} else {
				stopPicobot();
			}
		}
		
		function startPicobot() {
			if (complete) {
				complete = false;
				createWorld();
			}
			if (updateTimer == "") {
				evaluatePicobotPosition();
				updateTimer = window.setInterval("update()", speed);
				document.getElementById('startStop').innerText = "Stop";
			}
		}

		function stopPicobot() {
			if (updateTimer != "") {
				window.clearInterval(updateTimer);
				updateTimer = "";
				document.getElementById('startStop').innerText = "Start";

				updatePicobotImage();
				state = State.IDLE;

				evaluatePicobotPosition();
			}
		}

		function step() {
			oneStep = true;
			startStop();
		}
		
		function validateSurroundingsToken(lineNum, token) {
			var normalizedToken = "";
			if (token.match(/^[news]{1,4}$/i)) {
				var letters = "nNeEwWsS";
				for (i = 0; i < letters.length; i++) {
					var letter = letters.charAt(i);
					var pattern = new RegExp(letter, "g");
					var match = token.match(pattern)
					if (match && match.length > 1) {
						errorOnLine(lineNum, "surroundings '"+token+"' cannot have more than one of the same letter");
						return null;
					} else if (match && match.length == 1) {
						normalizedToken += letter;
					}
				}
				for (i = 0; i < letters.length; i++) {
					var letter = letters.charAt(i);
					var pattern = new RegExp(letter, "gi");
					var match = token.match(pattern);
					if (match && match.length > 1) {
						errorOnLine(lineNum, "surroundings '"+token+"' cannot have the same letter in both lower and upper case");
						return null;
					}
				}
			} else {
				errorOnLine(lineNum, "surroundings '"+token+"' is too long or contains illegal characters");
				return null;
			}
			return normalizedToken;
		}
		
		function error(message) {
			rules = [];
			surroundings.innerHTML = "Error: " + message;
			surroundings.style.display = "block";
			document.getElementById('logCheckbox').checked = true;
			document.getElementById('startStop').disabled = true;
			document.getElementById('step').disabled = true;
		}
		
		function errorOnLine(lineNum, message) {
			rules = [];
			surroundings.innerHTML = "Error on line #" + lineNum + ": " + message;
			surroundings.style.display = "block";
			document.getElementById('logCheckbox').checked = true;
			document.getElementById('startStop').disabled = true;
			document.getElementById('step').disabled = true;
		}
		
		function interpretRules() {
			randomPicobot();
			createWorld();
			var new_rules = [];
			surroundings.innerHTML = "";
			var textarea = document.getElementById('codebox');

			// parse textarea
			var str = textarea.value;
			var lines = str.split("\n");

			var ParserState = {
				STATE_TOKEN: 0,
				SURROUNDINGS: 1,
				ARROW: 2,
   				NEXT_DIR: 3,
				NEXT_STATE: 4
			};

			var i;
			var parserState = ParserState.STATE_TOKEN;

			var rule = {
				state: 0,
				match: "",
				next_direction: "",
				next_state: 0 
			};

			for(i = 0; i < lines.length; i++) {
				// Sanify line
				var line = lines[i];
				var new_line = line;
				do {
					line = new_line;
					new_line = line.replace(/\s\s/, " ");
				} while (new_line != line);
				line = line.replace(/^\s*/, "");
				line = line.replace(/\s*$/, "");

				if (line == "") {
					continue;
				}
				rule.lineNum = i + 1;
				
				// Pull out parts according to current parser state
				words = line.split(" ");

				for (var k = 0; k < words.length; k++) {
					var token = words[k];
					// Handle Comments
					if (token.match(/^\#/)) {
						break;
					} else if (k > 4) {
						errorOnLine(rule.lineNum, "expected end of line after rule, found '"+token+"'");
						return;
					}
					
					switch(parserState) {
						case ParserState.STATE_TOKEN:
							// Might allow words here...
							var ruleState = parseInt(token);
							if (isNaN(ruleState)) {
								errorOnLine(rule.lineNum, "expected number for rule state, found '"+token+"'");
								return;
							} else {
								rule.state = ruleState;
							}
							break;
						case ParserState.SURROUNDINGS:
							// Should contain 'newsNEWS' and nothing else
							rule.match = validateSurroundingsToken(rule.lineNum, token);
							if (rule.match == null)
								return;
							break;
						case ParserState.ARROW:
							// Check that token == '->'
							if (token == '->') {
								// all good
							} else {
								errorOnLine(rule.lineNum, "expected '->', found '"+token+"'");
								return;
							}
							break;
						case ParserState.NEXT_DIR:
							if (token == 'N' || token == 'n') {
								rule.next_direction = Direction.UP;
							} else if (token == 'S' || token == 's') {
								rule.next_direction = Direction.DOWN;
							} else if (token == 'E' || token == 'e') {
								rule.next_direction = Direction.RIGHT;
							} else if (token == 'W' || token == 'w') {
								rule.next_direction = Direction.LEFT;
							} else if (token == 'X' || token == 'x') {
								rule.next_direction = "";
							} else {
								errorOnLine(rule.lineNum, "expected N, E, W, S, or X for move direction, found '"+token+"'");
								return;
							}
							break;
						case ParserState.NEXT_STATE:
							var nextState = parseInt(token);
							if (isNaN(nextState)) {
								errorOnLine(rule.lineNum, "expected number for next state, found '"+token+"'");
								return;
							} else {
								rule.next_state = nextState;
								rule.next_state = parseInt(token);
								new_rules.push(rule); 
								rule = {
									lineNum: i + 1,
									state: 0,
									match: "",
									next_direction: Direction.UP,
									next_state: 0 
								};					
							}

							break;
					}
					parserState++;
					parserState %= 5;
				}
			}
			
			rules = validateRules(new_rules);
			if (rules == null)
				return;
			document.getElementById('startStop').disabled = false;
			document.getElementById('step').disabled = false;
			document.getElementById('enterRules').disabled = true;
		}
		
		function validateRules(rules) {
			// check for rules in state 0 (starting state)
			var hasState0 = false;
			for (i = 0; i < rules.length; i++) {
				var rule = rules[i];
				if (rule.state == 0) {
					hasState0 = true;
					break;
				}
			}
			if (!hasState0) {
				error("there are no rules for the starting state (state 0)");
				return null;
			}
			
			// check: if rules define transition to state N, there should be rules for state N
			var transitionStates = [];
			var ruleStates = [];
			for (i = 0; i < rules.length; i++) {
				var rule = rules[i];
				if (transitionStates.lastIndexOf(rule.next_state) == -1)
					transitionStates.push(rule.next_state);
				if (ruleStates.lastIndexOf(rule.state) == -1)
					ruleStates.push(rule.state);
			}
			for (i = 0; i < transitionStates.length; i++) {
				var transitionState = transitionStates[i];
				if (ruleStates.lastIndexOf(transitionState) == -1) {
					error("rules define transition to state "+transitionState+" but there are no rules for that state");
					return null;
				}
			}
			
			// check for duplicate rules (same state+surroundings)
			// surroundings strings got normalized to NEWS order during parsing
			var keys = [];
			for (i = 0; i < rules.length; i++) {
				var rule = rules[i];
				var key = rule.state + ":" + rule.match;
				if (keys.lastIndexOf(key) == -1) {
					keys.push(key);
				} else {
					error("line #"+rule.lineNum+" defines a rule for state "+rule.state+" and surroundings "+rule.match+" but these are already used by another rule");
					return null;
				}
			}
			
			return rules;
		}
		
		function textChanged() {
			stopPicobot();
			document.getElementById('startStop').disabled = true;
			document.getElementById('step').disabled = true;
			document.getElementById('enterRules').disabled = false;
		}
		
		function logSurroudings() {
			if (verboseLog) {
				var str = "";
				if (isWall(picobot[0], picobot[1]-1)) {
					str = str + "North ";
				}	
				if (isWall(picobot[0]+1, picobot[1])) {
					str = str + "East ";
				}
				if (isWall(picobot[0]-1, picobot[1])) {
					str = str + "West ";
				}
				if (isWall(picobot[0], picobot[1]+1)) {
					str = str + "South ";
				}
				var words = str.split(" ");
				words.pop(); // chomp trailing space
				str = words.join(", ");
				return "Walls to " + str;
			} else {
				var str = "surroundings: ";
				if (isWall(picobot[0], picobot[1]-1)) {
					str = str + "N";
				}	
				else {
					str = str + "n";
				}
				if (isWall(picobot[0]+1, picobot[1])) {
					str = str + "E";
				}
				else {
					str = str + "e";
				}
				if (isWall(picobot[0]-1, picobot[1])) {
					str = str + "W";
				}
				else {
					str = str + "w";
				}
				if (isWall(picobot[0], picobot[1]+1)) {
					str = str + "S";
				}
				else {
					str = str + "s";
				}
				return str;
			}
		}
		
		function logRule(rule) {
			var str = "";
			if (verboseLog) {
				str += "state " + rule.state + ", ";

				var wallsStr = "";
				if (rule.match.match(/N/))
					wallsStr += "North, ";
				if (rule.match.match(/E/))
					wallsStr += "East, ";
				if (rule.match.match(/W/))
					wallsStr += "West, ";
				if (rule.match.match(/S/))
					wallsStr += "South, ";
				if (wallsStr.length > 0)
					str += "walls " + wallsStr;

				var openStr = "";
				if (rule.match.match(/n/))
					openStr += "North, ";
				if (rule.match.match(/e/))
					openStr += "East, ";
				if (rule.match.match(/w/))
					openStr += "West, ";
				if (rule.match.match(/s/))
					openStr += "South, ";
				if (openStr.length > 0)
					str += "open " + openStr;
				
				str += "move ";
				if (rule.next_direction.match(/N/))
					str += "North, ";
				else if (rule.next_direction.match(/E/))
					str += "East, ";
				else if (rule.next_direction.match(/W/))
					str += "West, ";
				else if (rule.next_direction.match(/S/))
					str += "South, ";
				
				str += "next state " + rule.next_state;
			} else {
				str += rule.state + " ";
				str += rule.match + " -> ";
				str += rule.next_direction + " ";
				str += rule.next_state;
			}
			return str;
		}
		
		function outputStatus(rule) {
			
			if (complete) {
				surroundings.innerHTML += "STEP "+stepNum+": Complete!"+"\n";
				surroundings.scrollTop = surroundings.scrollHeight;	// scroll to end
				return;
			}
			
			surroundings.innerHTML += "STEP " + stepNum++ + 
			": state " + picobot_state + 
			"; " + logSurroudings() + 
			"; Applying rule #" + rule.lineNum + 
			": " + logRule(rule) + "\n";
			surroundings.scrollTop = surroundings.scrollHeight; // scroll to end
			
		}
		
		var i = 0;
		function update() {
			// Smooth movement code:
			if (state == State.MOVING) {
				var current_top = parseInt(picobot_cell.style.top);
				var current_left = parseInt(picobot_cell.style.left);
				var new_value = 0;
				if (movingDirection == Direction.UP) {
					new_value = current_top - 5;
					picobot_cell.style.top = new_value + "px";
				}
				else if (movingDirection == Direction.DOWN) {
					new_value = current_top + 5;
					picobot_cell.style.top = new_value + "px";
				}
				else if (movingDirection == Direction.LEFT) {
					new_value = current_left - 5;
					picobot_cell.style.left = new_value + "px";
				}
				else if (movingDirection == Direction.RIGHT) {
					new_value = current_left + 5;
					picobot_cell.style.left = new_value + "px";
				} else {
					new_value = OFFSET;
				}

				if (new_value % 20 == OFFSET) {
					state = State.IDLE;

					// We choose a new rule
					do {
						// We evaluate the current position
						evaluatePicobotPosition();
						if (oneStep) {
							stopPicobot();
							oneStep = false;
						}

						picobot_rule_invoked = chooseRule();

						if (picobot_rule_invoked == "") {
							// No rules!
						} else {
							
							outputStatus(picobot_rule_invoked);
							
							if (picobot_rule_invoked.next_direction != "") {
								// We carry out the rule
								movePicobot(picobot_rule_invoked.next_direction);
							}
						}
					} while(picobot_rule_invoked.next_direction == "");
				}
			} else {
				state = State.MOVING;
				movingDirection = "";
				/*
				var y = picobot[1];
				if (i % 2) {
					movePicobot(Direction.UP);
				}
				else {
					movePicobot(Direction.DOWN);
				}
				if (y == picobot[1]) {
					i++;
				}
				*/
			}
		}
		</script>
		
		<style>
			.world_container {
				width: 504px;
				height: 504px;
			}

			.world_container > div {
			}
			
			.code_box {
				width: 500px;
				height: 496px;

				background-color: white;

				font-family: monospace;
				font-size: 14px;
				line-height: 16px;

				border: 0;
			}

			.code_box_numbers {
				border:1px solid gray;
				font-family: monospace;
				color: gray;
				background-color: #ddd;
				font-size: 14px;
				line-height: 16px;
			}

			.code_box_lines{
				font-family: monospace;
				border-right: 1px solid gray;
				padding-right: 3px;
				font-size: 14px;
				line-height: 16px;
			}
			
			.picobot_cell {
				position: absolute;

				left: 70px;
				top: 50px;
				
				width: 20px;
				height: 20px;

				background-image: url('img/red.gif');
				z-index: 0;
			}
			
			.world_box {
				width: 500px;
				height: 500px;

				border: 2px solid gray;

				line-height: 0;

				background-image: url('img/world_bg.png');

				margin: 0;
				padding: 0;
			}

			.cell {
				width:20px;
				height:20px;

				z-index: -1;
			}
			
			.output_box {
				width:1024px;
				height:200px;
				font-family: monospace;
				display: none;
			}

			button {
				width:80px;
				margin:2px;
			}
			
			img {
				margin: 0;
				padding: 0;
			}

			td {
				margin: 0;
				padding: 0;
			}

			tr {
				margin: 0;
				padding: 0;
			}

			table {
				margin: 0;
				padding: 0;
			}

			body {
				font-family:sans-serif;
				font-size:12px;
				margin: 0;
				padding: 0;
			}
		</style>
		<title>Picobot</title>
	</head>
	<body onload="initialize()">
		<table cellspacing = 0 cellpadding = 0>
			<tr>
				<td>
					<div class="world_box" id="world"></div>
					<div>
<!-- nudging unused in this version
						<button onclick="nudgePicobot(Direction.UP)">Up</button> | <button onclick="nudgePicobot(Direction.DOWN)">Down</button> |
						<button onclick="nudgePicobot(Direction.LEFT)">Left</button> | <button onclick="nudgePicobot(Direction.RIGHT)">Right</button> |
-->
						<button id="startStop" onclick="startStop()">Start</button> | 
						<button id="step" onclick="step()">Step</button>

<!-- color change unused in this version
						<br/>

						<button onclick="changePicobotColor(Color.RED)">Red</button> | <button onclick="changePicobotColor(Color.GREEN)">Green</button>
-->
						|
						<select onchange="changeMap(this)">
							<option value="0" selected>Map 0: Open Square</option>
							<option value="1">Map 1: Diamond</option>
							<option value="2">Map 2: Maze</option>
							<option value="3">Map 3: Rooms A</option>
							<option value="4">Map 4: Rooms B</option>
							<option value="5">Map 5: Obstacles</option>
							<option value="6">Map 6: Rooms + Obstacles</option>
						</select>	
						|
						<select onchange="changeSpeed(this)">
							<option value="1" selected>Faster</option>
							<option value="12">Fast</option>
							<option value="25">Medium</option>
							<option value="37">Slow</option>
							<option value="50">Slower</option>
						</select>	
					</div>
				</td>
				<td valign="top">
					<textarea class="code_box" id="codebox" wrap="off" onkeydown="textChanged()">
# Current_State surroundings -> Go_Direction Go_into_state

# Capital letters for walls, lowercase letters for openings
# NeWs : Wall to north and west, opening to east and south

# State 0 is always the starting state

# Example: When we are in state 0, and east is clear,
# don't move anywhere and go to state 1
# 0 e -> X 1

# This example just goes up and down...

0 n -> N 0   # when in state 0 with opening to north,
             #    go north and stay in state 0
0 N -> X 1   # when in state 0 with wall to north,
             #    stop and switch to state 1

1 s -> S 1   # when in state 1 with opening to south,
             #    go south and stay in state 1
1 S -> X 0   # when in state 1 with wall to south,
             #    stop and switch to state 0

</textarea>

						<button id="enterRules" onclick="interpretRules()">Enter Rules</button>
						<label><input type="checkbox" id="logCheckbox" onclick="toggleLog(this)"/>Show Debugging Log</label>
						<label><input type="checkbox" onclick="toggleVerbose(this)"/>Verbose Logging</label>
				</td>
			</tr>
		</table>
		<textarea class="output_box" id="surroundings"></textarea>
	</body>
</html>
